module Main where

import Control.Monad.State.Strict
import Data.Monoid
import System.Environment
import System.IO

import BrainFree
import Instructions
import Runtime

defaultMemSize :: Int
defaultMemSize = 30000

-- | Evaluate a brainfuck program in the BF monad.
eval :: [Instr] -> BF ()
eval = mapM_ eval1
    where
        eval1 (IMovePtr n)      = movePtr n
        eval1 (IAddPtr off c)   = readPtr off >>= writePtr off . (+ c)
        eval1 (IInput off)      = getChr >>= maybe (return ()) (writePtr off . coerce)
        eval1 (IOutput off)     = readPtr off >>= putChr . coerce
        eval1 (ILoop off body)  = loop off (eval body)
        eval1 (IWritePtr off c) = writePtr off c
        eval1 (IMultPtr dstOff srcOff c) = do
            x <- readPtr dstOff
            y <- readPtr srcOff
            writePtr dstOff $ x + y*c

-- | Run a bf program in 'IO' using a 'VectorMem' data store.
runVecMem :: [Instr] -> IO ()
runVecMem = withVectorMem defaultMemSize . evalStateT . runBFM step . eval
    where
        step (MovePtr n k)      = modify (vecMove n) >> k
        step (ReadPtr off k)    = get >>= vecRead off >>= k
        step (WritePtr off c k) = get >>= vecWrite off c >> k
        step (GetChar k)        = getc >>= k
        step (PutChar c k)      = putc c >> k
        step (Loop off body k)  = bfLoopM (get >>= vecRead off) (runBFM step body) >> k

-- | Run a bf program in 'IO' using a 'FPtrMem' data store.
runFPtrMem :: [Instr] -> IO ()
runFPtrMem = withFPtrMem defaultMemSize . evalStateT . runBFM step . eval
    where
        step (MovePtr n k)      = modify (fptrMove n) >> k
        step (ReadPtr off k)    = get >>= fptrRead off >>= k
        step (WritePtr off c k) = get >>= fptrWrite off c >> k
        step (GetChar k)        = getc >>= k
        step (PutChar c k)      = putc c >> k
        step (Loop off body k)  = bfLoopM (get >>= fptrRead off) (runBFM step body) >> k

-- | Run a bf program using an infinite 'Tape'.
--
-- To make it interesting, does not use auxiliary monads, but instead
-- endomorphisms of @'Tape' -> 'Offset' -> 'String' -> 'String'@.
-- The result is an 'interact'-style @'String' -> 'String'@ function
-- that takes a 'String' for input and produces a 'String' as output.
runTape :: [Instr] -> String -> String
runTape prog = appEndo (toTapeAction $ eval prog) finish blankTape 0
    where
        toTapeAction :: BF () -> TapeAction
        toTapeAction bf = runBF step (bf >> return mempty)

        step :: BFF (TapeAction) -> TapeAction
        step (MovePtr n k)      = changeRefPos n <> k
        step (ReadPtr off k)    = moveToOffset off <> tread k
        step (WritePtr off c k) = moveToOffset off <> twrite c <> k
        step (GetChar k)        = tgetc k
        step (PutChar c k)      = tputc c <> k
        step (Loop off body k)  = loop' <> k
            where loop' = moveToOffset off <> whenNZ (toTapeAction body <> loop')

        finish :: Tape -> Offset -> String -> String
        finish _ _ _ = ""

type TapeAction = Endo (Tape -> Offset -> String -> String)

-- | Change the tape reference position (no need to move the tape itself).
changeRefPos :: Int -> TapeAction
changeRefPos n = Endo $ \k t p i -> k t (p - n) i

-- | Move the tape to an offset relative to the current reference position.
moveToOffset :: Offset -> TapeAction
moveToOffset off = Endo $ \k t p i -> k (tapeMove (off - p) t) off i

tread :: (Cell -> TapeAction) -> TapeAction
tread f = Endo $ \k t p i -> appEndo (f (tapeRead t)) k t p i

twrite :: Cell -> TapeAction
twrite c = Endo $ \k t p i -> k (tapeWrite c t) p i

tgetc :: (Maybe Char -> TapeAction) -> TapeAction
tgetc f = Endo $ \k t p i ->
    case i of
        c : cs -> appEndo (f (Just c)) k t p cs
        []     -> appEndo (f Nothing) k t p []

tputc :: Char -> TapeAction
tputc c = Endo $ \k t p i -> c : k t p i

-- | Execute the given tape action when the cell at tape head is non-zero.
whenNZ :: TapeAction -> TapeAction
whenNZ ta = Endo $ \k t p i ->
    if tapeRead t /= 0
        then appEndo ta k t p i
        else k t p i

-- | Use 'interact' to actually run the result of 'runTape' in 'IO'.
--
-- Note that 'interact' closes the stdin handle at the end, so this
-- can't be used to run multiple programs in the same session.
runTapeIO :: [Instr] -> IO ()
runTapeIO = interact . runTape

-- | Generate C code for a bf program.
generateC :: [Instr] -> IO ()
generateC bf = putStr . unlines $
    [ "/* generated by brainfree */"
    , "unsigned char m[30000], *p = m;"
    , "int main(void) {" ]
    ++ genBlock bf
    ++ [indent "return 0;", "}"]
    where
        indent = ("  " ++)
        genBlock = map indent . concatMap step
        step (IMovePtr n)       = ["p += " ++ show n ++ ";"]
        step (IAddPtr off c)    = ["p[" ++ show off ++ "] += " ++ show c ++ ";"]
        step (IInput off)       = ["p[" ++ show off ++ "] = getchar();"]
        step (IOutput off)      = ["putchar(p[" ++ show off ++ "]);"]
        step (ILoop off body)   = ["while (p[" ++ show off ++ "]) {"]
                                    ++ genBlock body
                                    ++ ["}"]
        step (IWritePtr off c)  = ["p[" ++ show off ++ "] = " ++ show c ++ ";"]
        step (IMultPtr o1 o2 c) = ["p[" ++ show o1 ++ "] += p[" ++ show o2 ++ "] * " ++ show c ++ ";"]

-- | Generate Haskell code for a bf program.
generateHS :: [Instr] -> IO ()
generateHS bf = putStr . unlines $
    [ "import Runtime"
    , "import Control.Applicative"
    , "import Control.Monad.State.Strict"
    , "import System.IO"
    , "rd off = get >>= fptrRead off"
    , "wr off n = get >>= fptrWrite off n"
    , "main = hSetBuffering stdout NoBuffering >> run"
    , "run = withFPtrMem 30000 . evalStateT $ do"
    ] ++ genBlock bf
    where
        indent = ("  " ++)
        genBlock = map indent . concatMap step
        step (IMovePtr n)       = ["modify $ fptrMove (" ++ show n ++ ")"]
        step (IAddPtr off c)    = ["rd (" ++ show off ++ ") >>= wr (" ++ show off ++ ") . (+ (" ++ show c ++ "))"]
        step (IInput off)       = ["bfInputM getc (wr (" ++ show off ++ "))"]
        step (IOutput off)      = ["bfOutputM (rd (" ++ show off ++ ")) putc"]
        step (ILoop off body)   = ("bfLoopM (rd " ++ show off ++ ") $ do") : genBlock body
        step (IWritePtr off c)  = ["wr (" ++ show off ++ ") (" ++ show c ++ ")"]
        step (IMultPtr o1 o2 c) = ["((+) <$> rd " ++ show o1 ++ " <*> ((* " ++ show c ++ ") <$> rd " ++ show o2 ++ ")) >>= wr " ++ show o1]

-- | Handle command line arguments.
processArgs :: ([Instr] -> IO ()) -> Bool -> [String] -> IO ()
processArgs _ o ("-v":args) = processArgs runVecMem o args
processArgs _ o ("-f":args) = processArgs runFPtrMem o args
processArgs _ o ("-t":args) = processArgs runTapeIO o args
processArgs _ o ("-c":args) = processArgs generateC o args
processArgs _ o ("-h":args) = processArgs generateHS o args
processArgs r _ ("-o":args) = processArgs r True args
processArgs _ _ (('-':_):_) = usage
processArgs runner o (filename:_) =
    parseFile filename >>= either print (runner . if o then optimize else id)
processArgs _ _ _ = usage

usage :: IO ()
usage = putStrLn "usage: brainfree [-v|-f|-t] [-o] FILENAME"

main :: IO ()
main = do
    hSetBuffering stdout NoBuffering
    getArgs >>= processArgs runVecMem False
